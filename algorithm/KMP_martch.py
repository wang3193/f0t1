'''
KMP算法.由3名科学家的姓名拼接来,
和BM算法思路类似,将专注点放在了已匹配的前缀上,
在已匹配的前缀中,在主串中查找最长可匹配后缀子串,用来匹配模式串中已匹配子串的前缀,该子串也就是,模式串的最长可匹配前缀子串
例如: 主串为:GTGTGAGCTGAS 模式串为: GTGTGCF 
则匹配串为 GTGTG, 最长可匹配后缀子串为GTG, 
找到该子串后,将模式串的位置移至最长可匹配后缀开始处即可,然后重复该步骤

如何找到字符串前缀最长可匹配前缀子串:
事先将最长可匹配前缀子串缓存到一个集合中.该集合呗成为next数组
next集合为一个一维整数数组,角标为已匹配前缀的下一个位置,值为最长可匹配子串的下一个位置.
使用时,坏字符串所在位置即是next集合的角标位置.取里面的值即可知道最长匹配浅醉的下一个位置.
如何使用模式串生成next子串
使用动态规划法,next[0]和next[1]的值肯定为0,因为此时前缀字段长度小于等于1.由next[2]开始,
next[i+1]都可以使用next[i]推导出来
推导过程
设变量i为next待填充的数组角标
设变量j为最长可匹配前缀子串的角标,即待填充的数组值
因为前2位元素不会有已匹配子串,所以前next[0] = 0, next[1] = 0, j = 0, i = 2, 
如果子串v中,v[j] = v[i-1], 那么将j+1写入next[i]中.
如果v[j] != v[i-1], 将j回退再比较,直到j变为0


''' 