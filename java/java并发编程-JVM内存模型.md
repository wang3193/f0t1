# 并发问题的原因
- 1.多核CPU的缓存带来的可见性问题
- 2. 代码编译优化导致的有序性问题
# Java内存模型
- 用于解决JVM如何按需禁用缓存和编译优化
- 包括volatile, synchronized, final关键字, 六项happens-before规则
# volatile关键字
- 禁用CPU缓存
- 生效原因: JDK1.5增加的一项happens-before规则


# happens-before:
1. 程序的顺序性规则
- 在一个线程中,按照程序顺序,前面的操作先于后续的任意操作
2. volatile变量规则
- volatile变量的写操作先于读操作
3. 传递性
- 如果A 先于B, B先于C,则A先于C
4. 管程中锁的规则
- 一个锁的解锁先于后续对这个锁的枷锁
5. 线程start()规则
- 线程的start()操作先于被start线程中的任意操作
6. 线程join()规则
- 线程A调用线程B的join()并成功返回,那么B中的任何操作先于join()操作的返回

# final
- 告诉编译器,该变量不变化,可以无底线优化
- JDK1.5之后对final的重排进行了约束

# 管程(Monitor):
- 管程是一种通用的同步原语,在java中就是synchronized,synchronized是java对管程的实现.
- 管程指的是管理共享变量以及对共享变量的操作过程,让他们支持并发.
- 管程中的锁是隐式的,枷锁解锁的过程由编译器实现.
- 管程和信号量等价,管程可以实现信号量,信号量也可以实现管程
## 三种模型:
- Hasen模型, Hoare模型,MESA模型
## MESA模型:
### 互斥:
- 管程将共享变量及对共享变量的操作统一封装起来
### 同步:
## java中实现:
- Lock, Condition,
- await(), signal();

# 信号量(Semaphore)
## 模型:
- 一个计数器,一个等待队列,三个方法
- init(), down(), up()
- init: 设置计数器的初始值
- down: 计数器的值减1,如果此时计数器的值小于0,则当前线程将被阻塞,否则当前线程可以继续执行
- up: 计数器的值+1;如果此时计数器的值小于或等于0,则唤醒等待队列的一个线程,并将其从等待队列移除
## java中的使用
- acquire = down()
- release = up()
## 和管程的区别:
- Sempahore可以允许多个线程访问一个临界区


# 并发编程需要注意的问题
## 安全性问题
- 程序按照我们期望的执行.
- 存在共享数据并且该数据会发生变化,才会导致安全性问题.
- ThreadLocalStorage, TLS, 不变模式都是基于避免共享数据方案

## 活跃性问题
- 活跃性问题指某个炒作无法执行下去
- 死锁,活锁,饥饿
- 死锁: 2个线程互相持有对方的锁,等待对方释放,解决死锁:破坏死锁必要条件之一
- 活锁: 线程没有发生阻塞,但依旧无法执行,解决活锁,谦让时等待随机事件
- 饥饿: 线程一直无法访问到所需资源而无法执行.解决方案: 1.保证资源充足2.公平分配资源.3避免持有资源的线程长时间运行
## 性能问题
- 串行化的范围过大,影响代码的效率
1. 使用无锁的算法和数据结构.如ThreadLocalStorage,写入时复制(copy-on-write),乐观锁,并发包中的原子类,Disruptor
2. 减少锁的持有时间.例如使用细粒度锁:ConcurrentHashMap,读写锁

# 读写锁
- 读写锁允许多个线程同时读取共享变量,适用于读多写少的场景
- 持有读锁时,无法获取写锁,持有写锁时,可同时获取读锁.即java不支持锁升级,支持锁的降级

# StampedLock
- 分为写锁,悲观读锁,乐观读
- 写锁与悲观读锁与读写锁语义相同
- tryOptimisticRead()乐观读是一种无锁操作

# CountDownLatch:
- 解决一个线程等待多个线程的场景
- 内置计数器,计数器减为0之后,执行调用了await()方法的线程

# CyclicBarrier:
- 处理一组线程之间互相等待
- 原理:内置计数器,每个线程完成计数-1,此时计数器大于0时会让该线程等待,=0时,通知后续线程,并唤醒等待线程,将计数器重置
- 创建cyclicBarrier 时,传入回调函数,在计数器减为0时,会调用该回调函数
